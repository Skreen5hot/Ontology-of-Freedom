document.addEventListener('DOMContentLoaded', () => {
    const ONTOLOGY_PREFIX = 'http://example.org/moral_sandbox#';
    const RDF_TYPE = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';
    const RDFS_LABEL = 'http://www.w3.org/2000/01/rdf-schema#label';
    const OWL_CLASS = 'http://www.w3.org/2002/07/owl#Class';
    const XSD_BOOLEAN = 'http://www.w3.org/2001/XMLSchema#boolean';

    let knowledgeStore = new N3.Store(); // Store for loaded knowledge base
    let generatedQuads = []; // Quads for rules generated by the builder

    // --- DOM Elements ---
    const knowledgeFileInput = document.getElementById('knowledgeFileInput');
    const ttlOutput = document.getElementById('ttlOutput');
    const generateTtlBtn = document.getElementById('generateTtl');
    const downloadTtlBtn = document.getElementById('downloadTtl');
    const clearOutputBtn = document.getElementById('clearOutput');
    const clearFormBtn = document.getElementById('clearForm');

    // Moral Rule Elements
    const moralRuleId = document.getElementById('moralRuleId');
    const moralRuleLabel = document.getElementById('moralRuleLabel');
    const moralRuleAppliesToClass = document.getElementById('moralRuleAppliesToClass');
    const moralRuleDeonticStatus = document.getElementById('moralRuleDeonticStatus');
    const moralRuleMoralJudgment = document.getElementById('moralRuleMoralJudgment');
    const moralRuleViolatesValue = document.getElementById('moralRuleViolatesValue');
    const moralRuleHasMoralValue = document.getElementById('moralRuleHasMoralValue');
    const moralRuleJustification = document.getElementById('moralRuleJustification');
    const addMoralRuleBtn = document.getElementById('addMoralRule');

    // Classification Rule Elements
    const classificationRuleId = document.getElementById('classificationRuleId');
    const classificationRuleLabel = document.getElementById('classificationRuleLabel');
    const classificationRuleClassToAssign = document.getElementById('classificationRuleClassToAssign');
    const classificationRuleRequiresIntent = document.getElementById('classificationRuleRequiresIntent');
    const classificationRuleRequiresPerformerIsNotOwner = document.getElementById('classificationRuleRequiresPerformerIsNotOwner');
    const classificationRuleRequiresAction = document.getElementById('classificationRuleRequiresAction');
    const classificationRuleRequiresArtifact = document.getElementById('classificationRuleRequiresArtifact');
    const addClassificationRuleBtn = document.getElementById('addClassificationRule');

    // --- Event Listeners ---
    knowledgeFileInput.addEventListener('change', loadKnowledgeBase);
    addMoralRuleBtn.addEventListener('click', addMoralRule);
    addClassificationRuleBtn.addEventListener('click', addClassificationRule);
    generateTtlBtn.addEventListener('click', generateFullTtl);
    downloadTtlBtn.addEventListener('click', downloadTtl);
    clearOutputBtn.addEventListener('click', () => { ttlOutput.value = ''; });
    clearFormBtn.addEventListener('click', clearAllForms);

    // --- Functions ---

    async function loadKnowledgeBase(event) {
        const file = event.target.files[0];
        if (!file) return;

        const fileContent = await file.text();
        try {
            const parser = new N3.Parser();
            knowledgeStore = new N3.Store(); // Clear previous store
            parser.parse(fileContent, (error, quad) => {
                if (error) {
                    console.error('Error parsing loaded knowledge base:', error);
                    alert('Failed to parse knowledge base. Check console for details.');
                    return;
                }
                if (quad) {
                    knowledgeStore.addQuad(quad);
                } else {
                    console.log('Knowledge base loaded successfully.');
                    populateDropdowns();
                }
            });
        } catch (error) {
            console.error('Error loading knowledge base:', error);
            alert('Failed to load knowledge base. Check console for details.');
        }
    }

    function populateDropdowns() {
        const classes = getEntitiesByType(OWL_CLASS);
        const values = getEntitiesByType(ONTOLOGY_PREFIX + 'Value');
        const intents = getEntitiesByType(ONTOLOGY_PREFIX + 'Intent');
        const actions = getEntitiesByType(ONTOLOGY_PREFIX + 'Action');
        const artifacts = getEntitiesByType(ONTOLOGY_PREFIX + 'Artifact');

        fillSelect(moralRuleAppliesToClass, classes);
        fillSelect(classificationRuleClassToAssign, classes);
        fillSelect(moralRuleViolatesValue, values);
        fillSelect(moralRuleHasMoralValue, values);
        fillSelect(classificationRuleRequiresIntent, intents);
        fillSelect(classificationRuleRequiresAction, actions);
        fillSelect(classificationRuleRequiresArtifact, artifacts);
    }

    function getEntitiesByType(typeUri) {
        const entities = new Set();
        knowledgeStore.getQuads(null, RDF_TYPE, typeUri).forEach(quad => {
            const label = knowledgeStore.getObjects(quad.subject, RDFS_LABEL, null)[0]?.value || quad.subject.value.split('#').pop();
            entities.add({ id: quad.subject.value, label: label });
        });
        // Also include subclasses if the type is a class
        if (typeUri === OWL_CLASS || typeUri.endsWith('Action')) {
            knowledgeStore.getQuads(null, 'http://www.w3.org/2000/01/rdf-schema#subClassOf', typeUri).forEach(quad => {
                const label = knowledgeStore.getObjects(quad.subject, RDFS_LABEL, null)[0]?.value || quad.subject.value.split('#').pop();
                entities.add({ id: quad.subject.value, label: label });
            });
        }
        return Array.from(entities).sort((a, b) => a.label.localeCompare(b.label));
    }

    function fillSelect(selectElement, options) {
        selectElement.innerHTML = '<option value="">-- Select --</option>';
        if (selectElement.multiple) {
            selectElement.innerHTML = ''; // No default for multiple select
        }
        options.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.id;
            opt.textContent = option.label;
            selectElement.appendChild(opt);
        });
    }

    function addMoralRule() {
        const writer = new N3.Writer({ prefixes: { ex: ONTOLOGY_PREFIX, rdfs: RDFS_LABEL.substring(0, RDFS_LABEL.lastIndexOf('#') + 1), xsd: XSD_BOOLEAN.substring(0, XSD_BOOLEAN.lastIndexOf('#') + 1) } });
        const { namedNode, literal, quad } = N3.DataFactory;

        const id = moralRuleId.value.trim();
        if (!id) { alert('Moral Rule ID is required.'); return; }

        const ruleNode = namedNode(ONTOLOGY_PREFIX + id);
        writer.addQuad(ruleNode, namedNode(RDF_TYPE), namedNode(ONTOLOGY_PREFIX + 'MoralRule'));
        if (moralRuleLabel.value.trim()) writer.addQuad(ruleNode, namedNode(RDFS_LABEL), literal(moralRuleLabel.value.trim()));
        if (moralRuleAppliesToClass.value) writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'appliesToClass'), namedNode(moralRuleAppliesToClass.value));
        if (moralRuleDeonticStatus.value) writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'hasDeonticStatus'), literal(moralRuleDeonticStatus.value));
        if (moralRuleMoralJudgment.value) writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'hasMoralJudgment'), literal(moralRuleMoralJudgment.value));
        if (moralRuleJustification.value.trim()) writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'justificationText'), literal(moralRuleJustification.value.trim()));

        Array.from(moralRuleViolatesValue.selectedOptions).forEach(option => {
            writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'violatesValue'), namedNode(option.value));
        });
        Array.from(moralRuleHasMoralValue.selectedOptions).forEach(option => {
            writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'hasMoralValue'), namedNode(option.value));
        });

        writer.end((error, result) => {
            if (error) { console.error(error); alert('Error generating Moral Rule TTL.'); return; }
            generatedQuads.push(result);
            ttlOutput.value += `\n# --- New Moral Rule: ${id} ---\n${result}\n`;
            clearMoralRuleForm();
        });
    }

    function addClassificationRule() {
        const writer = new N3.Writer({ prefixes: { ex: ONTOLOGY_PREFIX, rdfs: RDFS_LABEL.substring(0, RDFS_LABEL.lastIndexOf('#') + 1), xsd: XSD_BOOLEAN.substring(0, XSD_BOOLEAN.lastIndexOf('#') + 1) } });
        const { namedNode, literal, quad } = N3.DataFactory;

        const id = classificationRuleId.value.trim();
        if (!id) { alert('Classification Rule ID is required.'); return; }

        const ruleNode = namedNode(ONTOLOGY_PREFIX + id);
        writer.addQuad(ruleNode, namedNode(RDF_TYPE), namedNode(ONTOLOGY_PREFIX + 'ClassificationRule'));
        if (classificationRuleLabel.value.trim()) writer.addQuad(ruleNode, namedNode(RDFS_LABEL), literal(classificationRuleLabel.value.trim()));
        if (classificationRuleClassToAssign.value) writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'classToAssign'), namedNode(classificationRuleClassToAssign.value));
        if (classificationRuleRequiresIntent.value) writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'requiresIntent'), namedNode(classificationRuleRequiresIntent.value));
        if (classificationRuleRequiresPerformerIsNotOwner.checked) writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'requiresPerformerIsNotOwner'), literal('true', namedNode(XSD_BOOLEAN)));
        if (classificationRuleRequiresAction.value) writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'requiresAction'), namedNode(classificationRuleRequiresAction.value));
        if (classificationRuleRequiresArtifact.value) writer.addQuad(ruleNode, namedNode(ONTOLOGY_PREFIX + 'requiresArtifact'), namedNode(classificationRuleRequiresArtifact.value));

        writer.end((error, result) => {
            if (error) { console.error(error); alert('Error generating Classification Rule TTL.'); return; }
            generatedQuads.push(result);
            ttlOutput.value += `\n# --- New Classification Rule: ${id} ---\n${result}\n`;
            clearClassificationRuleForm();
        });
    }

    function generateFullTtl() {
        const writer = new N3.Writer({
            prefixes: {
                ex: ONTOLOGY_PREFIX,
                rdfs: RDFS_LABEL.substring(0, RDFS_LABEL.lastIndexOf('#') + 1),
                owl: OWL_CLASS.substring(0, OWL_CLASS.lastIndexOf('#') + 1),
                xsd: XSD_BOOLEAN.substring(0, XSD_BOOLEAN.lastIndexOf('#') + 1),
            }
        });

        // Add all quads from the loaded knowledge base first (optional)
        knowledgeStore.forEach(quad => writer.addQuad(quad));

        // Add all generated quads
        generatedQuads.forEach(ttlString => {
            // N3.Writer.addQuad expects quads, not TTL strings.
            // We need to re-parse the generated TTL strings back into quads.
            const parser = new N3.Parser();
            parser.parse(ttlString, (error, quad) => {
                if (error) { console.error("Error re-parsing generated quad string:", error); return; }
                if (quad) writer.addQuad(quad);
            });
        });

        writer.end((error, result) => {
            if (error) { console.error(error); alert('Error generating full TTL.'); return; }
            ttlOutput.value = result;
        });
    }

    function downloadTtl() {
        const filename = 'generated_rules.ttl';
        const blob = new Blob([ttlOutput.value], { type: 'text/turtle' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
    }

    function clearMoralRuleForm() {
        moralRuleId.value = '';
        moralRuleLabel.value = '';
        moralRuleAppliesToClass.value = '';
        moralRuleDeonticStatus.value = '';
        moralRuleMoralJudgment.value = '';
        moralRuleViolatesValue.selectedIndex = -1; // Deselect all
        moralRuleHasMoralValue.selectedIndex = -1; // Deselect all
        moralRuleJustification.value = '';
    }

    function clearClassificationRuleForm() {
        classificationRuleId.value = '';
        classificationRuleLabel.value = '';
        classificationRuleClassToAssign.value = '';
        classificationRuleRequiresIntent.value = '';
        classificationRuleRequiresPerformerIsNotOwner.checked = false;
        classificationRuleRequiresAction.value = '';
        classificationRuleRequiresArtifact.value = '';
    }

    function clearAllForms() {
        clearMoralRuleForm();
        clearClassificationRuleForm();
        generatedQuads = []; // Also clear the internal list of generated quads
        ttlOutput.value = ''; // Clear the output area
    }

    // Initial population of dropdowns (if no knowledge base is loaded yet, they will be empty)
    populateDropdowns();
});